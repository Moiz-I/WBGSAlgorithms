TL;DR - We use the Euclidean Algorithm to calculate the GCD of a pair of numbers. You express the larger number as a multiple of the smaller one plus a remainder, then the smaller number is the new larger one, and the remainder is the new smaller one. Make this algorithm and test it with some numbers.

<h1>Day 3</h1>
<h2>The Euclidean Algorithm</h2>
Taking a break from our ongoing series on searching and sorting, let's take the opportunity to investigate one of my favourite algorithms from Elementary Number Theory, the Euclidean Algorithm.

You may recognise it from Computing Lessons, as it was given as a test question at one point or possible as an example, but either way, I doubt you have seen it in Maths.

The first time I saw this algorithm I was shocked at its simplicity, because it is able to calculate the GCD/HCF of a pair of numbers without much calculation at all.

<h3>Algorithm</h3>
In this formulation, I use the mathematical notation (a,b) which means the HCF of a and b, and [a,b] which means the LCM of a and b.

Here is a nice Khan Academy page explaining the Euclidean Algorithm, with examples: https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm

The Euclidean calculates the Highest Common Factor of a pair of positive integers, doing this in a different way to the traditional prime factors method.

Here is some pseudocode which describes the algorithm, without giving away exactly how to program it.

```
Let the larger integer be a.
Let the smaller integer be b.
Let c.
WHILE b is not equal to zero:
	Express a as x*b + c where x is some positive integer, and 0 <= c < b.
	Set a <-- b.
	Set b <-- c.
ENDWHILE
The Highest Common Factor is a. 
```

If your chosen language offers DO/WHILE, you might find it easier/as easy to implement the algorithm using that technique, although it seems that this pseudocode works fine without it.

<h3>Task</h3>
The task for today is to produce a program that implements the Euclidean Algorithm to calculate the HCF of two integers.

<h3>Extensions</h3>
<ol>
<li>Try to make your program work for negative integers. It would seem that this same algorithm should work, but might need a few adjustments.</li>
<li>Produce a program that can calculate the LCM of two integers, and verify the result that (a,b) * [a,b] &#8801; a*b. This program can use whichever method you choose. For example, the prime factorisation method, or the comparison of multiples of the two numbers. You may like to implement the prime factorisation/multiple listing in a separate function, called from the LCM function.</li>
<li>Prove the above result that (a,b) * [a,b] &#8801; a*b. </li>
<li>Try the other approach that you didn't try for the calculation of the LCM, and verify the different efficiencies of the two approaches. Compare with this the efficiency of using the result listed above to calculate the LCM, having calculated the HCF. You should be able to use your timer function from Monday if you did this extension. Otherwise you can simply get the time, run the relevant function, get the time again and subtract. I imagine you will find that the best method is multiplying the two numbers together and dividing by the HCF, generated by the Euclidean Algorithm, because neither repeated multiplication nor prime fatorisation is particularly efficient. In order to test this hypothesis, use loop over many large integers in the range 10^10 to 10^15 and calculate their LCMs to get a real feel for which algorithm takes longer.</li>
<li>You could calculate the complexity of each of these approaches and express it in Big O notation</li>
<li>Try to produce an algorithm which can calculate the HCF/LCM of 3 numbers. You may want to adapt the Euclidean Algorithm, use a different approach such as with prime numbers, or try to work it out from the comparison of the 3 possible pairs of numbers within the group of three. </li> 
<li>Having done this, find out if the identity (a,b,c) * [a,b,c] &#8801; a*b*c holds in the same way as for two values. </li>
<li>Finally, can you generalise the function so that it accepts any number of values and will tell you the HCF of all of these</li>
</ol>

Here is a link which describes and proves some of the approaches mentioned:

http://www.programming-algorithms.net/article/42865/Least-common-multiple

<h3>Tests</h3>

9876, 6493 --> 1 // Check coprime numbers

9006, 3002 --> 3002 // Check one is a multiple of the other

3002, 9006 --> 3002 // Check order

72, 58 --> 24 // Check numbers which share a factor that is not 1 but are not multiples of each other

0,8 --> 8 //0 is divisible by any non-0 integer 


You could also use the integer list generation function or the list of integers published in the linear search challenge to test this algorithm.


<h3>Hints</h3>

For the proof of the multiplication result, you can use the traditional method of prime factorisation, taking the existence of a unique factorisation for every integer as proven.

To calculate the HCF of 3 numbers, you could use the prime factor method, which is virtually unvaried from the two integer method. You still need to choose all of the prime factors that appear in all factorisations.

To use the multiplication method, again you just need to multiply to produce times tables of each of the three numbers, and look for values that appear in all three. You could either store all of the times tables for the first and second numbers in an array and then check for the third number in both arrays, making sure that the 1st number is the biggest, then 2nd, then 3rd.

If you are using the Euclidean algorithm, a bit more thought will be required to implement this directly, however you can just take the HCF of the first two integers, and of the second two, then take the HCF of the result. Can you verify that this works by prime factorisation? Consider all of the possible cases. 

For the final extension you have an unknown number of input variables into a function. This means you will need an array. 

You will need to work out which pairs of tests are sufficient to guarantee full coverage of the list; you may not need to use all possible combinations of two values.

You will likely want to use a recursive function to implement this, although as we know, iteration will work too. You can have the function call itself, reducing the number of values in the list by 1 each time, until only two are left. Then, you will return the HCF of these two all the way up the function chain. [I have not tested this but believe it to work]





These cases to consider are:
<ul>
<li>A prime factor features in the factorisation of 1 of the numbers a,b or c.</li>
<li>A prime factor features in the factorisation of a,b ; a,c or b,c.</li>
<li>A prime factor features in all three factorisations.</li>
</ul>

You can see from the above that the method outlined of taking ((a,b),(b,c)) will work because:
<ul>
<li>If a prime factor only divides a or b or c it won't divide (a,b) or (b,c) so won't feature in the result.</li>
<li>If a prime factor divides (a,b) but not c, it won't divide (b,c) so won't feature in the final result. The same applies to the case of b,c but not a.</li>
<li>If a prime factor divides (a,c) but not b, it won't feature in either of (a,b) or (b,c) so won't feature in the result.</li>
<li>If a prime factor features in all of the individual factorisations, it will divide (a,b) and (b,c) so will divide ((a,b),(b,c)) so will feature in the final result.</li>
</ul>

This means that you will only be left with the prime factors of a,b and c that feature in all three factorisations, which is the highest common factor.

Hence we have proved by exhaustion the effectiveness of this method.
